---
title: Introduction to Git
author: Dr. Carl G. Stahmer
date: December 2, 2020
output:
   rmdformats::readthedown
---

```{r, echo=FALSE}
url <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/mac_finder_1.png"
url2 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/mac_window_2.png"
url3 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/spoke_and_where_cloud.png"
url4 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/distributed_network.png"
url5 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/hybrid_network.png"
url6 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/empty_sectors.png"
url7 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/filled_bits.png"
url8 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/directory.png"
url9 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/mac_finder_3.png"
url10 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/version_tree.png"
url11 <- "https://datalab.ucdavis.edu/cstahmer/git_workshop_images/TT_tree_mobile.jpg"
```

# Introduction

Introduction to Git for Version Control covers the basics of using Git to track and record changes to files on your local computer so that you can compare versions over time and recall earlier versions later.  This is an hybrid workshop that includes this online tutorial and a live, virtual (Zoom), interactive, "Hand's On" session during which participants will use the Git Version Control System (VCS) to learn how to manage files on their local computer.  Particpants indepently review the materials in this online tutorial and have Git successfully installed on their local computer (covered in this tutorial) prior to attending the live, Virtual session.

The full workshop descritption can be found [here](https://datalab.ucdavis.edu/eventscalendar/workshop-introduction-to-version-control-with-git-live-session/).

# Interactive Session Information

The workshop includes a live, interactive session to be held via Zoom on Friday, December 11, 2020 from 12:00 pm to 2:00 pm.  Zoom login inofmration will be sent to all registered participants via email.

# About this Tutorial
This online tutorial provides background information that will help participants to better understand the concepts introduced during the Interactive session.  It also includes information to help you successfully install Git on your local computer, which must be completed prior to the Interactive session.


# Objectives for this Workshop
``` {objective}
1. Learn about the history of VCS including its value and function;
2. Gain an understanding of how VCS mange files on your computer;
2. Successfully install and run the Git VCS on your local computer;
3. Learn how to interact with your computer using the Command Line;
4. Learn the basic basic Command Line commands needed to work with Git;
5. Successfully create local repositories;
6. Learn how to place files under version control;
7. Learn how to comapare multiple versions of the same file;
8. Learn how to roll-back to earlier versions of a file;
9. Perform basic branching and merging;
10. Understand basic Git Workflows.
```

# What is Version Control?

Version control describes a process of storing and organizing multiple versions/copies of documents that you create.  Approaches to version control range from the simple to the complex and can involve the use of various human workflows and/or software applications to accomplish the overall goal of storing and managing multiple versions of the same document(s).  

Most people have a folder/directory somewhere on their computer that looks something like this:

![](`r url`)

Or perhaps, this:

![](`r url2`)

This is a rudimentary form of version control that relies completely on the human workflow of saving multiple versions of a file.  Such a system works minimally well, in that it does provide you with a history of file versions.  But the filesystem method provides no information about how the file has changed from version to version, why you might have saved a particular version, or how the veracious versions are related, other than their time sequency.  They are also more subject to error than software-assisted version control systems as it is not uncommon for users to make mistakes when naming file versions.  Software-assisted version control systems such as Git were designed to solve this problem.

# Software Assisted Version Control

Version control software has its roots in the software development community, where it is common for many coders to work on the same file, sometimes synchronously, amplifying the need to track and understand revisions.  But nearly all types of computer files, not just code, can be tracked using modern version control systems.  IBM’s OS/360 IEBUPDTE software update tool is widely regarded as the earliest, widely adopted precursor to modern, version control systems, with the release in 1972 of the Source Code Control System (SCCS) package marking the first, fully fledged system designed specifically for software version control. 

Today’s marketplace offers many options when it comes to choosing a version control software system.  They include systems such as Git, Visual Source Safe, Subversion, Mercurial, CVS, and Plastic SCM, to name a few.  Each of these systems offers its twist on version control, differing sometimes in the area of user functionality, sometimes in how it handles things on the back-end, and sometimes both. This tutorial focuses on the Git version control system, but in the sections that follow we offer some general information about classes of version control systems to help you better understand how Git does what it does and help you make more informed decisions about how to deploy it.

# Local vs Server Based Version Control

Generally speaking there are two types of version control systems:  Local and Server (sometimes called Cloud) based systems.  When working with a Local version control system, all files, metadata, and everything associated with the version control system lives on your local drive, in a universe unto itself.  Working locally is a perfectly reasonable option for those who work independently (not as part of team), have no need to regularly share their files or versions of them, and who have robust back-up practices for their local storage drive(s). 

Server based systems utilize software running on your local computer that communicates with a remote server (or servers) where it stores files and data.  Depending on the system being deployed, files and data may reside exclusively on the server, being downloaded to temporary local storage only when a file is being actively edited; or, the system may maintain continuous local and remote versions of your files.  Server based systems facilitate team science because they allow multiple users to have access to the same files via the server.  They can also provide an important, non-local back-up of your files, protecting you from loss of data should your local storage media fail.  

Git is a Server based version control system that can store files both locally and on a remote server.  While the sections that follow offer a broader description of Server based version control, in this workshop we will focus only on using Git locally and will not configure the software to communicate with, store files on, or otherwise interact with a remote server.  Our companion “Git for Teams” workshop focuses on using Git with the Github service to capitalize on Git’s distributed version control capabilities.  

# Central Version Control Systems

Server based version control systems can generally be segmented into two distinct categories:  1) Centralized Version Control Systems (Centralized VCS) and Distributed Version Control Systems (Distributed VCS).  Centralized VCS is the oldest and, surprisingly to many, still the dominant form of version control architecture worldwide.  Centralized VCS implement a “spoke and wheel” architecture to provided server based version control.  

![](`r url3`)

With the spoke and wheel architecture, the server maintains a centralized collection of file versions.  Users utilize version control clients to “check-out” a file of interest to their local file storage, where they are free to make changes to the file.  Centralized VCS typically restrict other users from checking out editable versions of a file if another user currently has the file checked out.  Once the user who has checked out the file has finished making changes, they “check-in” their new version, which is then stored on the server from where it can be retrieved by other users.  As can be seen, Centralized VCS provide a very controlled and ordered universe that ensures file integrity and tracking of changes.  However, this regulation comes at a cost.  Namely, it reduces the ease with which multiple users can work simultaneously on the same file.  

# Distributed Version Control Systems

Distributed Version Control Systems are not dependent on a central repository as a means of sharing files or tracking versions.  Distributed VCS implement a network architecture (as opposed to the spoke and wheel of the Centralized VCS as pictured above) to allow each user to communicate directly with every other user.

![](`r url4`)

In Distributed VCS, each user maintains their own version history of the files being tracked, and the VCS software communicates between users to keep the various local file systems in sync with each other.  With this type of system, the local versions of two different users will diverge from each other if both users make changes to the file.  This divergence will remain in place until the local repositories are synced, at which time the VCS stitches or merges the two different versions of the file into a single version that reflects the changes made by each individual and then saves the stitched version of the file onto both systems as the current version.  (The various mechanisms for resolving conflicts that may arise during this merge process.)  Distributed VCS offer greater flexibility and facilitate collaborative work, but a lack of understanding of the sync/merge workflow can cause problems.  It is not uncommon for a user to forget to synch their local repository with the repositories of other team members and, as a result, work for extended periods of time on outdated files that don’t reflect their teammates.  

# 1.5 The Best of Both Worlds

An important feature of Distributed VCS is that many users and organizations choose to include a central server as a node in the distributed network.  This creates an hybrid universe in which some users will sync directly to each other while other users will sync through a central server.

![](`r url5`)

Syncing with a cloud-based server provides an extra level of backup for your files and also facilitates communication between users.  But treating the server as just another node on the network as opposed to a centralized point of control put control and flexibility back in the hands of the individual developer.  For example, in a true Centralized CVS, if the server goes down then nobody can check files in and out of the server, which means that nobody can work.  But in a Distributed CVS this is not an issue.  Users can continue to work on local versions and the system will sync any changes when the server becomes available.  Git, which is the focus of this tutorial, is a Distributed VCS.  Users can use Git to share and sync repositories directly with other users or through a central Git server such as, for example, GitHub or GitLab.

# VCS and the Computer File System

When we think about Version Control, we typically think about managing changes to individual files.  From the user perspective, the File is typically the minimum accessible unit of information.  Whether working with images, tabular data, or written text, we typically use software to open a File that contains the information we want to view or edit.  As such, it comes as a surprise to most users that concept of Files, and their organizing containers, Folders or Directories, are not intrinsic to how computers themselves store and interact with data.  In this section of the tutorial we will learn about how computers store and access information and how VCS interact with this process to track and manage files.

# How Computers Store and Access Information

For all of their computing power and seeming intelligence, computers still only know two things: 0 and 1.  In computer speak, we call this a binary system, and the unit of memory on a hard-disk, flash drive, or computer chip that stores each 1 or 0 is called a bit.  You can think of your computer’s storage device (regardless of what kind it is) as a presenting a large grid, where each box is bit:

![](`r url6`)

In the above example, as with most computer storage, the bits in our storage grid are addressable, meaning that we can designate a particular bit using a row and column number such as, for example, A7, or E12.  Also, remember, that each bit can only contain one of two values:  0 or 1.  So, in practice, our storage grid would actually look something like this:

![](`r url7`)

All of the complex information that we store in the computer is translated to this binary language prior to storage using a system called Unicode.   You can think of Unicode as a codebook that assigns a unique combination of 8, 16, 32, 64, etc. (depending on how old your computer is) ones and zeros to each letter, numeral, or symbol. For example, the 8-bit Unicode for the upper case letter “A” is “01000001”, and the 8-bit Unicode character for the digit “3” is “00110011”.  The above grid actually spells out the phrase, “Call me Ishmael”, the opening line of Herman Melville’s novel Moby Dick.

An Important aspect of how computers story information in binary form is that, unlike most human readable forms of data storage, there is no right to left, up or down, or any other regularized organization of bits on a storage medium.  When you save a file on your computer, the computer simply looks for any open bits and starts recording information.   The net result is that the contents of single file are frequently randomly interleaved with data from other files.  This mode of storage is used because it maximizes the use of open bits on the storage device.  But it presents the singular problem of not making data readable in a regularized, linear fashion.  To solve this problem, all computers reserve a particular part of their internal memory for a “Directory” which stores a sector map of all chunks of data.  So, for example, if you create a file called README.txt with the word “hello” in it, the computer would randomly store the Unicode for the five characters in the word “hello” on the storage device and make a directory entry something like the following:

![](`r url8`)

Understanding the Directory concept and how computers store information is crucial to understanding how VCS mange your Files.

# How VCS Manage Your Files

Good VCS don’t actually manage files at all.  They manage Directories.  Most users think about version control as a process of managing files.  For example, if I might have a directory called “My Project” that holds several files related to this project as follows:  

![](`r url9`)

One approach to managing changes to the above project files would be to store multiple versions of each file as in the figure below for the file analysis.r:

![](`r url10`)

In fact, many VCS do exactly this.  Treating each file as the minimum unit of data and simply saving various versions of each file along with some additional information about the version.  This approach can work reasonably well.  However, it has limitations.  First, this approach can unnecessarily consume space on the local storage device, especially if you are saving many versions of a very large file.  It also has difficulty dealing with changes in filenames, typically treating the same file with a new name as a completely new file, thereby breaking the chain of version history.

To combat these issues, Distributed VCS like Git take an alternate approach to data storage that is Directory rather than file based.  

# Graph-Based Data Management

Git (and many other Distributed VCS) manage your files as collections of data rather than collections of files.  Git’s primary unit of management is the “Repository,” or “Repo” for short, which is aligned with your computer’s Directory/Folder structure.  Consider, for example, the following file structure:

![](`r url11`)

Here we see a user, Tom’s, home directory, which contains three sub directories (Data, Thesis, and Tools) and one file (Notes.txt).   Both the Data and Tools directories contain sub files and/or directories.  If Tom wanted to track changes to the two files in the Data directory, he would first create a Git repository by placing the Data directory “under version control.”  

When a repository is created, the Git system writes a collection of hidden files into the Data Directory that it uses to store information about all of the data that lives under that directory.  This includes information about the addition, renaming, and deletion of both files and folders as well as information about changes to the data contained in the files themselves.  Additions, deletions and versions of files are tracked and stored not as copies of files, but rather as a set of instructions that describes changes made to the underling data and the directory structure that describes them.  

# Installing Git 

In order to run Git version control and be ready for the interactive portion of the workshop, you’ll need to install on your local machine.  Please note that you must have git installed prior to attending the interactive session.  We will not take time during that session to handle installation issues.  And you don’t have Git installed, you won’t be able to follow along with the activities of the interactive session.  Git installation is typically an easy, point and click process, but there are some configuration steps along the way to which you’ll need to pay attention.

If you are installing Git on a Windows operating system, follow the instructions, using the same configuration options, in the following video:  

[How to Download and Install Git on Windows 10 & Choose Install Options](https://www.youtube.com/watch?v=nbFwejIsHlY)

If you are installing Git on a Mac, there is no extra configuration.  Simply go the git download page at [https://git-scm.com/downloads](https://www.youtube.com/watch?v=nbFwejIsHlY) and, choose the latest version for mac, and run the installer package when it is finished downloading.  If you get an “unknown developer” warning during the install process, follow the instructions at the beginning of the video at [https://www.youtube.com/watch?v=__kr-Ew5kbE ](https://www.youtube.com/watch?v=nbFwejIsHlY)to help you work through this problem.

WHETHER YOU’RE INSTALLING ON WINDOWS OR MAC, note that, unlike most applications that you’ve installed before, WHEN THE INSTALLATION IS COMPLETE YOU WON’T FIND A “GIT” APPLICATIO IN YOUR PROGRAMS OR APPLICATIONS DIRECTORY.  Git is a command-line application with which you interact using the command-line, which we’ll cover during the interactive session.  AS LONG AS YOU DON’T GET AN EXPLICIT ERROR MESSAGE DURING THE INSTALLATION PROCESS, YOU CAN ASSUME THAT THE SOFTWARE WAS SUCCESSFULLY INSTALLED.

If you are not able to successfully intall Git on your own, please attend DataLab's Virtual Office Hours, which are held every Monday afternoon from 1:30 to 3:00 pm, to get help with your installation.  Click [here](https://datalab.ucdavis.edu/office-hours/) for more information and to receive a Zoom link.


# Ready, Set, Go...

If you've read and understood the information in this online turorial and successfully installed Git on your local machine, you're ready for the interactive session to be held 

# Additional Resources

The[ Git Book](https://git-scm.com/book/en/v2) is the defintive Git resource and provides an excellent reference for everythign that we will cover in the Interactive session.  There is no need to read the book prior to the session, but it's a good reference resource to have avaialable as you begin to work with Git after the workshop.